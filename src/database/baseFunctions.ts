import type {Database} from 'firebase/database';
import {get, ref, child, push, onValue, off} from 'firebase/database';
import type {
  DrinkingSession,
  Profile,
  ProfileList,
  UserStatusList,
} from '@src/types/onyx';
import type {UserID} from '@src/types/onyx/OnyxCommon';
import DBPATHS from './DBPATHS';
import {diff, Diff, DiffArray} from 'deep-diff';

type FirebaseUpdates = {[key: string]: any};

/** Read data once from the realtime database using get(). Return the data if it exists.
 *
 * @param {Database} db The Realtime Database instance.
 * @param {string} refString Ref string to listen at
 * @returns {Promsise<any|null>}
 *
 * */
async function readDataOnce(
  db: Database,
  refString: string,
): Promise<any | null> {
  const userRef = ref(db, refString);
  const snapshot = await get(userRef); // One-off fetch
  if (snapshot.exists()) {
    return snapshot.val(); // Return user data
  }
  return null;
}

/**
 * Main listener for data changes
 *
 * @param db The Realtime Database instance.
 * @param refString Ref string to listen at
 * @param onDataChange Callback function to execute on data change.
 */
function listenForDataChanges(
  db: Database,
  refString: string,
  onDataChange: (data: any) => void,
) {
  const dbRef = ref(db, refString);
  const listener = onValue(dbRef, snapshot => {
    let data: any = null;
    if (snapshot.exists()) {
      data = snapshot.val();
    }
    onDataChange(data);
  });

  return () => off(dbRef, 'value', listener);
}

/**
 * Generates a database key based on the provided reference string.
 *
 * @param db The database object.
 * @param refString The reference string used to generate the key.
 * @returns The generated database key, or null if the key cannot be generated.
 */
function generateDatabaseKey(db: Database, refString: string): string | null {
  return push(child(ref(db), refString)).key;
}

/**
 * Fetches profile data for multiple users from the database.
 *
 * @param db - The database instance.
 * @param userIDs - An array of user IDs.
 * @param refTemplate - The reference template for fetching user data. Must contain the string '{userID}'.
 * @returns A promise that resolves to an array of profile data.
 */
function fetchDataForUsers(
  db: Database,
  userIDs: UserID[],
  refTemplate: string,
): Promise<Profile[]> {
  if (!userIDs || userIDs.length === 0) {
    return Promise.resolve([]);
  }
  if (!refTemplate.includes('{userID}')) {
    throw new Error('Invalid ref template');
  }
  return Promise.all(
    userIDs.map(id => readDataOnce(db, refTemplate.replace('{userID}', id))),
  );
}

/**
 * Fetches display data for the given user IDs.
 *
 * @param db - The database instance.
 * @param userIDs - An array of user IDs.
 * @param refTemplate - The reference template for fetching user data. Must contain the string '{userID}'.
 * @returns A promise that resolves to an object containing the display data.
 */
async function fetchDisplayDataForUsers(
  db: Database | undefined,
  userIDs: UserID[],
  refTemplate: string,
): Promise<ProfileList | UserStatusList> {
  const newDisplayData: ProfileList = {};
  if (db && userIDs) {
    const data: any[] = await fetchDataForUsers(db, userIDs, refTemplate);
    userIDs.forEach((id, index) => {
      newDisplayData[id] = data[index];
    });
  }
  return newDisplayData;
}

/**
 * Converts an array of differences between two objects into a nested updates object.
 * The updates object represents the changes needed to update the old object to the new object.
 *
 * @template T - The type of the objects being compared.
 * @param {Diff<T, T>[]} differences - An array of differences generated by comparing two objects.
 * @returns {Partial<T>} - A nested object representing the updates.
 */
function differencesToUpdates<T>(differences: Diff<T, T>[]): Partial<T> {
  const updates: Partial<T> = {};

  differences.forEach(difference => {
    const path = difference.path || [];

    if (path.length === 0) {
      return;
    }

    let current: any = updates;

    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      if (!(key in current)) {
        current[key] = {};
      }
      current = current[key];
    }

    const lastKey = path[path.length - 1];

    switch (difference.kind) {
      case 'N': // New property added
      case 'E': // Property edited
        current[lastKey] = difference.rhs;
        break;
      case 'D': // Property deleted
        current[lastKey] = null; // Or handle deletion as needed
        break;
      case 'A': // Array change
        if (!current[lastKey]) {
          current[lastKey] = [];
        }
        const arrayDiff = difference as DiffArray<any, any>;
        const arrayIndex = arrayDiff.index;
        const itemDiff = arrayDiff.item;

        if (itemDiff?.kind === 'N' || itemDiff?.kind === 'E') {
          current[lastKey][arrayIndex] = itemDiff.rhs;
        } else if (itemDiff?.kind === 'D') {
          current[lastKey][arrayIndex] = null; // Or remove the element
        }
        break;
      default:
        break;
    }
  });

  return updates;
}

/**
 * Converts a nested JavaScript object into a flattened object suitable for Firebase's `update` method.
 * Each key in the returned object represents a path in the database, and the value is the data to be set at that path.
 *
 * @template T - The type of the object to be converted.
 * @param {Partial<T>} updates - The nested object containing updates.
 * @param {string} [basePath=''] - An optional base path to prepend to all output keys.
 * @returns {FirebaseUpdates} - A flattened object with database paths as keys and update values.
 */
function buildUpdates<T>(
  updates: Partial<T>,
  basePath: string = '',
): FirebaseUpdates {
  const updatesToDB: FirebaseUpdates = {};

  function recurse(current: any, path: string = '') {
    for (const [key, value] of Object.entries(current)) {
      const currentPath = path ? `${path}/${key}` : key;
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        // Recursively handle nested objects
        recurse(value, currentPath);
      } else {
        // Set the value at the current path
        updatesToDB[currentPath] = value;
      }
    }
  }

  recurse(updates, basePath);
  return updatesToDB;
}

/**
 * Having a list of Firebase updates, prepend the base path to each key.
 *
 * @param updates A list of Firebase updates.
 * @param basePath The base path to prepend to each key.
 * @returns A list of Firebase updates with the base path prepended to each key.
 */
function prependFirebaseUpdateKeys(
  updates: FirebaseUpdates,
  basePath: string,
): FirebaseUpdates {
  const updatesWithBasePath: FirebaseUpdates = {};
  for (const [key, value] of Object.entries(updates)) {
    updatesWithBasePath[`${basePath}/${key}`] = value;
  }
  return updatesWithBasePath;
}

/**
 * Computes the differences between two objects and converts them into a flattened updates object suitable for Firebase's `update` method. This function effectively merges the functionality of computing differences and building the updates object.
 *
 * @template T - The type of the objects being compared.
 * @param {T} lhs - The original object (left-hand side).
 * @param {T} rhs - The updated object (right-hand side).
 * @param {string} basePath - An optional base path to prepend to all output keys.
 * @returns {{ [key: string]: any }} - A flattened object with database paths as keys and update values.
 */
function computeFirebaseUpdates<T>(
  lhs: T,
  rhs: T,
  basePath: string = '',
): FirebaseUpdates {
  const differences = diff(lhs, rhs) as Diff<T, T>[];
  if (!differences) {
    return {};
  }

  const updates = differencesToUpdates(differences);
  const updatesToDB = buildUpdates(updates, basePath);

  return updatesToDB;
}

/**
 * Cleans up updates by removing any overlapping paths where a parent is being set to null.
 *
 * @param updates - The updates object with paths as keys and values.
 * @returns - A new updates object with conflicting paths removed.
 */
function removeOverlappingUpdates(updates: FirebaseUpdates): FirebaseUpdates {
  const cleanUpdates: FirebaseUpdates = {};
  const paths = Object.keys(updates);

  // Collect all paths being set to null
  const nullPaths = new Set<string>();
  for (const path of paths) {
    if (updates[path] === null) {
      nullPaths.add(path);
    }
  }

  // Build a set of paths to exclude
  const excludePaths = new Set<string>();

  // For each nullPath, add its descendants to excludePaths
  for (const nullPath of nullPaths) {
    for (const path of paths) {
      if (path !== nullPath && path.startsWith(`${nullPath}/`)) {
        excludePaths.add(path);
      }
    }
  }

  // For each path, check if any of its ancestor paths are in nullPaths
  for (const path of paths) {
    if (excludePaths.has(path)) {
      continue; // Exclude this path
    }

    const pathSegments = path.split('/');

    let ancestorPath = '';
    let shouldExclude = false;

    for (let i = 0; i < pathSegments.length - 1; i++) {
      ancestorPath = ancestorPath
        ? `${ancestorPath}/${pathSegments[i]}`
        : pathSegments[i];

      if (nullPaths.has(ancestorPath)) {
        // Ancestor is being set to null, exclude this path
        shouldExclude = true;
        break;
      }
    }

    if (shouldExclude) {
      continue;
    }

    cleanUpdates[path] = updates[path];
  }

  return cleanUpdates;
}

/**
 * Determines if two paths conflict by checking if one path is strictly above or below the other.
 *
 * A conflict occurs if one path is a prefix of the other but not equal to it.
 * For example:
 * - "a/b" conflicts with "a/b/c" (above/below relationship).
 * - "a/b" does not conflict with "a/b" (equal paths).
 *
 * @param path1 - The first path as a string.
 * @param path2 - The second path as a string.
 * @returns `true` if `path1` and `path2` conflict; otherwise, `false`.
 */
function pathsConflict(path1: string, path2: string): boolean {
  if (path1 === path2) {
    return false;
  }
  const path1Parts = path1.split('/');
  const path2Parts = path2.split('/');

  if (path1Parts.length < path2Parts.length) {
    // path1 could be above path2
    const path2Prefix = path2Parts.slice(0, path1Parts.length).join('/');
    return path2Prefix === path1;
  } else if (path1Parts.length > path2Parts.length) {
    // path1 could be below path2
    const path1Prefix = path1Parts.slice(0, path2Parts.length).join('/');
    return path1Prefix === path2;
  } else {
    // Paths are of equal length but not the same; no conflict
    return false;
  }
}

/**
 * Merges a new set of updates into an existing set of updates, resolving path conflicts.
 *
 * If any key in the new updates conflicts with an existing key (one is strictly above or below the other),
 * the existing key is removed before merging the new updates.
 *
 * @param existingUpdates - An object representing the current set of updates, where keys are paths.
 * @param update - An object representing the new updates to be merged, where keys are paths.
 * @returns A new object representing the merged updates, with conflicts resolved.
 */
function mergeUpdates(
  existingUpdates: Record<string, any>,
  update: Record<string, any>,
) {
  const newUpdates = {...existingUpdates};

  for (const newKey of Object.keys(update)) {
    for (const existingKey of Object.keys(newUpdates)) {
      if (pathsConflict(existingKey, newKey)) {
        delete newUpdates[existingKey];
      }
    }
  }

  // Merge the new update into the updates
  Object.assign(newUpdates, update);

  // Update the reference
  return newUpdates;
}

export {
  buildUpdates,
  computeFirebaseUpdates,
  differencesToUpdates,
  fetchDataForUsers,
  fetchDisplayDataForUsers,
  generateDatabaseKey,
  listenForDataChanges,
  mergeUpdates,
  pathsConflict,
  prependFirebaseUpdateKeys,
  readDataOnce,
  removeOverlappingUpdates,
};
export type {FirebaseUpdates};
