import type {Database} from 'firebase/database';
import {get, ref, child, push, onValue, off} from 'firebase/database';
import type {
  DrinkingSession,
  Profile,
  ProfileList,
  UserStatusList,
} from '@src/types/onyx';
import type {UserID} from '@src/types/onyx/OnyxCommon';
import DBPATHS from './DBPATHS';
import {diff, Diff, DiffArray} from 'deep-diff';

/** Read data once from the realtime database using get(). Return the data if it exists.
 *
 * @param {Database} db The Realtime Database instance.
 * @param {string} refString Ref string to listen at
 * @returns {Promsise<any|null>}
 *
 * */
async function readDataOnce(
  db: Database,
  refString: string,
): Promise<any | null> {
  const userRef = ref(db, refString);
  const snapshot = await get(userRef); // One-off fetch
  if (snapshot.exists()) {
    return snapshot.val(); // Return user data
  }
  return null;
}

/**
 * Main listener for data changes
 *
 * @param db The Realtime Database instance.
 * @param refString Ref string to listen at
 * @param onDataChange Callback function to execute on data change.
 */
function listenForDataChanges(
  db: Database,
  refString: string,
  onDataChange: (data: any) => void,
) {
  const dbRef = ref(db, refString);
  const listener = onValue(dbRef, snapshot => {
    let data: any = null;
    if (snapshot.exists()) {
      data = snapshot.val();
    }
    onDataChange(data);
  });

  return () => off(dbRef, 'value', listener);
}

/**
 * Fetch the Firebase nickname of a user given their UID.
 * @param {Database} db The Realtime Database instance.
 * @param {string} uid The user's UID.
 * @returns{Promise<string|null>} The nickname or null if not found.
 *
 * @example const userNickname = await fetchNicknameByUID(db, "userUIDHere");
 */
async function fetchNicknameByUID(
  db: Database,
  uid: string,
): Promise<string | null> {
  const userRef = ref(db, DBPATHS.USERS_USER_ID_PROFILE.getRoute(uid));
  const userSnapshot = await get(userRef);
  if (!userSnapshot.exists()) {
    // console.error("No user found for the given UID.");
    return 'Not found';
  }
  return userSnapshot.val().display_name || null;
}

/**
 * Generates a database key based on the provided reference string.
 *
 * @param db The database object.
 * @param refString The reference string used to generate the key.
 * @returns The generated database key, or null if the key cannot be generated.
 */
function generateDatabaseKey(db: Database, refString: string): string | null {
  return push(child(ref(db), refString)).key;
}

/**
 * Fetches profile data for multiple users from the database.
 *
 * @param db - The database instance.
 * @param userIDs - An array of user IDs.
 * @param refTemplate - The reference template for fetching user data. Must contain the string '{userID}'.
 * @returns A promise that resolves to an array of profile data.
 */
function fetchDataForUsers(
  db: Database,
  userIDs: UserID[],
  refTemplate: string,
): Promise<Profile[]> {
  if (!userIDs || userIDs.length === 0) {
    return Promise.resolve([]);
  }
  if (!refTemplate.includes('{userID}')) {
    throw new Error('Invalid ref template');
  }
  return Promise.all(
    userIDs.map(id => readDataOnce(db, refTemplate.replace('{userID}', id))),
  );
}

/**
 * Fetches display data for the given user IDs.
 *
 * @param db - The database instance.
 * @param userIDs - An array of user IDs.
 * @param refTemplate - The reference template for fetching user data. Must contain the string '{userID}'.
 * @returns A promise that resolves to an object containing the display data.
 */
async function fetchDisplayDataForUsers(
  db: Database | undefined,
  userIDs: UserID[],
  refTemplate: string,
): Promise<ProfileList | UserStatusList> {
  const newDisplayData: ProfileList = {};
  if (db && userIDs) {
    const data: any[] = await fetchDataForUsers(db, userIDs, refTemplate);
    userIDs.forEach((id, index) => {
      newDisplayData[id] = data[index];
    });
  }
  return newDisplayData;
}

/**
 * Converts an array of differences between two objects into a nested updates object.
 * The updates object represents the changes needed to update the old object to the new object.
 *
 * @template T - The type of the objects being compared.
 * @param {Diff<T, T>[]} differences - An array of differences generated by comparing two objects.
 * @returns {Partial<T>} - A nested object representing the updates.
 */
function differencesToUpdates<T>(differences: Diff<T, T>[]): Partial<T> {
  const updates: Partial<T> = {};

  differences.forEach(difference => {
    const path = difference.path || [];

    if (path.length === 0) {
      return;
    }

    let current: any = updates;

    for (let i = 0; i < path.length - 1; i++) {
      const key = path[i];
      if (!(key in current)) {
        current[key] = {};
      }
      current = current[key];
    }

    const lastKey = path[path.length - 1];

    switch (difference.kind) {
      case 'N': // New property added
      case 'E': // Property edited
        current[lastKey] = difference.rhs;
        break;
      case 'D': // Property deleted
        current[lastKey] = null; // Or handle deletion as needed
        break;
      case 'A': // Array change
        if (!current[lastKey]) {
          current[lastKey] = [];
        }
        const arrayDiff = difference as DiffArray<any, any>;
        const arrayIndex = arrayDiff.index;
        const itemDiff = arrayDiff.item;

        if (itemDiff?.kind === 'N' || itemDiff?.kind === 'E') {
          current[lastKey][arrayIndex] = itemDiff.rhs;
        } else if (itemDiff?.kind === 'D') {
          current[lastKey][arrayIndex] = null; // Or remove the element
        }
        break;
      default:
        break;
    }
  });

  return updates;
}

/**
 * Converts a nested JavaScript object into a flattened object suitable for Firebase's `update` method.
 * Each key in the returned object represents a path in the database, and the value is the data to be set at that path.
 *
 * @template T - The type of the object to be converted.
 * @param {Partial<T>} updates - The nested object containing updates.
 * @returns {{ [key: string]: any }} - A flattened object with database paths as keys and update values.
 */
function buildUpdates<T>(updates: Partial<T>): {
  [key: string]: any;
} {
  const updatesToDB: {[key: string]: any} = {};

  function recurse(current: any, path: string = '') {
    for (const [key, value] of Object.entries(current)) {
      const currentPath = path ? `${path}/${key}` : key;
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        // Recursively handle nested objects
        recurse(value, currentPath);
      } else {
        // Set the value at the current path
        updatesToDB[currentPath] = value;
      }
    }
  }

  recurse(updates);
  return updatesToDB;
}

/**
 * Computes the differences between two objects and converts them into a flattened updates object
 * suitable for Firebase's `update` method. This function effectively merges the functionality of
 * computing differences and building the updates object.
 *
 * @template T - The type of the objects being compared.
 * @param {T} lhs - The original object (left-hand side).
 * @param {T} rhs - The updated object (right-hand side).
 * @returns {{ [key: string]: any }} - A flattened object with database paths as keys and update values.
 */
function computeFirebaseUpdates<T>(lhs: T, rhs: T): {[key: string]: any} {
  const differences = diff(lhs, rhs) as Diff<T, T>[];
  if (!differences) {
    return {};
  }

  const updatesToDB: {[key: string]: any} = {};

  differences.forEach(difference => {
    const path = difference.path || [];

    if (path.length === 0) {
      return;
    }

    const dbPath = path.join('/');

    switch (difference.kind) {
      case 'N': // New property added
      case 'E': // Property edited
        updatesToDB[dbPath] = difference.rhs;
        break;
      case 'D': // Property deleted
        updatesToDB[dbPath] = null; // Or handle deletion as needed
        break;
      case 'A': // Array change
        const arrayDiff = difference as DiffArray<any, any>;
        const arrayIndex = arrayDiff.index;
        const itemDiff = arrayDiff.item;

        const arrayPath = `${dbPath}/${arrayIndex}`;

        if (itemDiff?.kind === 'N' || itemDiff?.kind === 'E') {
          updatesToDB[arrayPath] = itemDiff.rhs;
        } else if (itemDiff?.kind === 'D') {
          updatesToDB[arrayPath] = null; // Or remove the element
        }
        break;
      default:
        break;
    }
  });

  return updatesToDB;
}

export {
  buildUpdates,
  computeFirebaseUpdates,
  differencesToUpdates,
  fetchDataForUsers,
  fetchDisplayDataForUsers,
  fetchNicknameByUID,
  generateDatabaseKey,
  listenForDataChanges,
  readDataOnce,
};
